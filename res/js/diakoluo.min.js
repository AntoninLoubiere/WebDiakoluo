

/* ######################### res/js/diakoluo/database.js ##########################*/

const EDIT_KEY = "edit";
const DATABASE_VERSION = 3;

/* the manager of the database */
class DatabaseManager {
    constructor() {
        this.testDB = null;
        this.testDBEditor = null;

        this.freeIndex = null;

        this.initAsyncFunc = this.initialise();
    }

    /* initialise the db */
    async initialise() {
        return new Promise((resolve, reject) => {
            this.testDB = indexedDB.open('tests', DATABASE_VERSION);
            this.testDB.onerror = function(event) {
                console.error('Database cannot be loaded', event);
                reject();
            };

            this.testDB.onsuccess = event => {
                this.testDBEditor = event.target.result;
                this.testDBEditor.onerror = this.onTestDBError;

                // get the last obhect key
                this.testDBEditor.transaction(['header']).objectStore('header').openCursor(null, "prev").onsuccess = event => {
                    var cursor = event.target.result;
                    if (cursor) {
                        if (cursor.key == EDIT_KEY) {
                            cursor.continue();
                            return;
                        }
                        this.freeIndex = cursor.key + 1;
                    } else {
                        this.freeIndex = 1;
                    }
                    console.info("Database loaded. Version", DATABASE_VERSION);
                    resolve();
                };
            }

            this.testDB.onupgradeneeded = event => {
                this.testDBEditor = event.target.result;

                this.testDBEditor.onerror = this.onTestDBError;



                switch (event.oldVersion) {
                    default:
                        var header = this.testDBEditor.createObjectStore("header", { keyPath: "id" });

                        header.createIndex("title", "title", { unique: false });
                        header.createIndex("description", "description", { unique: false });
                        header.createIndex("playable", "playable", { unique: false });

                        var tests = this.testDBEditor.createObjectStore("tests", { keyPath: "id" }); // same id as above.

                        tests.createIndex("title", "title", { unique: false });
                        tests.createIndex("description", "title", { unique: false });

                    case 1:
                        var playContexts = this.testDBEditor.createObjectStore("playContexts", 
                        { 
                            autoIncrement: true, 
                            keyPath: "pk"
                        });
                        playContexts.createIndex("testId", "testId");
                        playContexts.createIndex("gameId", "gameId");
                        playContexts.createIndex("testContext", ["testId", "gameId"], { unique: true });

                    case 2:
                        var sharedTests = this.testDBEditor.createObjectStore(
                            "sharedTests", 
                            { autoIncrement: true, keyPath: "pk" }
                        );
                        sharedTests.createIndex("authAccount", "authAccount");
                        sharedTests.createIndex("testId", "testId");
                        sharedTests.createIndex("serverTestId", "serverTestId");
                        sharedTests.createIndex("lastModification", "lastModification");

                }
                console.info("Database initialised or upgraded from version", event.oldVersion, "to", DATABASE_VERSION);
            };

            // set storage persistent if possible, else, warn the user
            if (navigator.storage && navigator.storage.persist) {
                navigator.storage.persist().then(function(persistent) {
                    if (!persistent) {
                        I18N.initAsyncFunc.then(() => Modal.showOkModal(
                            'error-storage-p-title', 
                            'error-storage-p-message', 
                            {important: true, showAgain: 'modal-persist-p-storage'}
                        ));
                    }
                });
            } else {
                I18N.initAsyncFunc.then(() => Modal.showOkModal(
                    'error-storage-c-title', 
                    'error-storage-c-message', 
                    {important: true, showAgain: 'modal-persist-c-storage'}
                ));
            }
        });
    }

    /* callback when an error occur on the database */
    onError(event) {
        let e = event.target.error;
        console.error("In testDB, error nÂ°" + e.code + " occur !\n\n" + e.name + "\n" + e.message, {e}, event);
    }

    /* add a new test */
    addNewTest(test) {
        test.id = this.freeIndex;
        this.freeIndex++;
        var transaction = this.testDBEditor.transaction(['header', 'tests'], "readwrite");
        var header = transaction.objectStore('header');
        var tests = transaction.objectStore('tests');

        header.add(test.getHeader());
        return tests.add(test);
    }

    /* add a play context */
    addPlayContext(context, pageConstructor) {
        context.gameId = pageConstructor.DB_GAME_ID;

        this.testDBEditor
            .transaction(['playContexts'], 'readwrite')
            .objectStore('playContexts')
            .add(context)
            .onsuccess = function(event) {
                context.pk = event.target.result; // set the pk found
            };
    }

    /* update a test */
    updateTest(test) {
        var transaction = this.testDBEditor.transaction(['header', 'tests'], "readwrite");
        var header = transaction.objectStore('header');
        var tests = transaction.objectStore('tests');

        header.put(test.getHeader());
        return tests.put(test);
    }

    /* update the play context */
    updatePlayContext(context) {
        var playContexts = this.testDBEditor.transaction(['playContexts'], 'readwrite').objectStore('playContexts');
        return playContexts.put(context);
    }

    /* delete a test */
    deleteTest(id) {
        var transaction = this.testDBEditor.transaction(['header', 'tests'], "readwrite");
        var header = transaction.objectStore('header');
        var tests = transaction.objectStore('tests');

        this.deleteAllPlayContext(id);

        header.delete(id);
        return tests.delete(id);
    }

    /* delete all play context of a specific test */
    deleteAllPlayContext(testId) {
        var transaction = this.testDBEditor.transaction(['playContexts'], "readwrite");
        var playContextsIndex = transaction.objectStore('playContexts').index('testId');

        playContextsIndex.openCursor(IDBKeyRange.only(testId)).onsuccess = function(event) {
            var cursor = event.target.result;
            if (cursor) {
                cursor.delete();
                cursor.continue();
            }
        }
    }

    /* get if a test exist */
    testExist(id) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['header'], "readonly");
            var tests = transaction.objectStore(['header']);
            var r = tests.get(id);
            r.onsuccess = () => {
                if (r.result) {
                    resolve(true);
                } else {
                    resolve(false);
                }
            }

            r.onerror = reject;
        });
    }

    /* get if a test is playable */
    getPlayable(id) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['header'], "readonly");
            var tests = transaction.objectStore(['header']);
            var r = tests.get(id);
            r.onsuccess = event => {
                if (r.result) {
                    resolve(r.result.playable);
                } else {
                    reject(event);
                }
            }

            r.onerror = reject;
        });
    }

    /**
     * Get the header of a test.
     * @param {number} id the id of the test
     * @returns A promise that return the header of a test
     */
    getHeader(id) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['header'], "readonly");
            var tests = transaction.objectStore(['header']);
            var r = tests.get(id);
            r.onsuccess = event => {
                if (r.result) {
                    resolve(r.result);
                } else {
                    reject(event);
                }
            }

            r.onerror = reject;
        });
    }

    /* get a full test data*/
    getFullTest(id) {
        var transaction = this.testDBEditor.transaction(['tests'], "readonly");
        var tests = transaction.objectStore(['tests']);
        var r = tests.get(id);
        var o = {onsuccess: null, onerror: null};
        r.onsuccess = event => {
            var test = event.target.result;
            if (test) {
                try {
                    test = Test.cast(test);  
                } catch(e) {
                    console.error("Error while casting the test !", e);
                    if (o.onerror) o.onerror(event);
                    return;
                }
                if (o.onsuccess) o.onsuccess(test);
            } else {
                if (o.onerror) o.onerror(event);
                
            }
        }

        r.onerror = () => {
            if (o.onerror) o.onerror(event);
            else indexedDB.onerror(event);
        }

        return o;
    }

    /* get a play context */
    getPlayContext(testId, pageConstructor) {
        return this.testDBEditor
            .transaction(['playContexts'], 'readonly')
            .objectStore('playContexts')
            .index('testContext')
            .openCursor(
                IDBKeyRange.only([testId, pageConstructor.DB_GAME_ID])
            );
    }

    /* get the cursor to get all children */
    forEachHeader() {
        return this.testDBEditor.transaction(['header']).objectStore('header').openCursor();
    }

    /* get the cursor to get all children (except edit) */
    forEach(callback) {
        this.testDBEditor.transaction(['tests']).objectStore('tests').openCursor().onsuccess = event => {
            var cursor = event.target.result;
            if (cursor) {
                var id = cursor.value.id;
                if (id != EDIT_KEY) {
                    try {
                        var test = Test.cast(cursor.value);
                    } catch(e) {
                        console.error("Error while casting the test !", e);
                        cursor.continue();
                        return;
                    }
                    callback(test);
                }
                cursor.continue();
            } else {
                callback();
            }
        };
    }

    /**
     * Add a sync test.
     * @param {*} syncObject the sync object to add
     * @returns a promise
     */
     addSync(syncObject) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['sharedTests'], "readwrite");
            var sharedTests = transaction.objectStore('sharedTests');
            var request = sharedTests.add(syncObject);
            request.onsuccess = resolve;
            request.onerror = reject;
        });
    }

    /**
     * Get a sync test.
     * @param {number} pk the primary key
     * @returns a promise
     */
     getSync(pk) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['sharedTests'], "readonly");
            var sharedTests = transaction.objectStore('sharedTests');
            var request = sharedTests.get(pk);
            request.onsuccess = resolve;
            request.onerror = reject;
        });
    }

    /**
     * Update a sync test.
     * @param {*} syncObject the sync object to update
     * @returns a promise
     */
     updateSync(syncObject) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['sharedTests'], "readwrite");
            var sharedTests = transaction.objectStore('sharedTests');
            var request = sharedTests.put(syncObject);
            request.onsuccess = resolve;
            request.onerror = reject;
        });
    }

    /**
     * Delete a synchronise test.
     * @param {number} pk the primary key of the object to delete
     */
    deleteSync(pk) {
        return new Promise((resolve, reject) => {
            var transaction = this.testDBEditor.transaction(['sharedTests'], "readwrite");
            var sharedTests = transaction.objectStore('sharedTests');
            var request = sharedTests.delete(pk);
            request.onsuccess = resolve;
            request.onerror = reject;
        });
    }

    /**
     * For each share
     * @returns the cursor opened
     */
    forEachSync() {
        return this.testDBEditor.transaction(['sharedTests'], 'readwrite').objectStore('sharedTests').openCursor();
    }
}

const DATABASE_MANAGER = new DatabaseManager();


/* ########################### res/js/diakoluo/main.js ############################*/



/* ####################### res/js/diakoluo/file-manager.js ########################*/

class FILE_MANAGER {

    static CSV_SEPARATOR = ',';
    static CSV_LINE_SEPARATOR = '\n';

    /* export the test (download the file) */
    static exportTest(test) {
        const t = FILE_MANAGER.getTestBlob(test);
        const a = document.createElement('a');  

        a.href= URL.createObjectURL(t);
        a.download = test.getFilename();
        a.click();

        URL.revokeObjectURL(t);
    }

    /* export the test in the csv format*/
    static exportCsvTest(test, columnName, columnType) {
        const t = FILE_MANAGER.getTestBlobCsv(test, columnName, columnType);
        const a = document.createElement('a');  

        a.href= URL.createObjectURL(t);
        a.download = test.getFilename();
        a.click();

        URL.revokeObjectURL(t);
    }

    /* export all tests */
    static async exportAllTest() {
        var t = await FILE_MANAGER.getAllTestBlobCsv()
        const a = document.createElement('a');  

        a.href= URL.createObjectURL(t);
        a.download = I18N.getTranslation('export-all-filename');
        a.click();

        URL.revokeObjectURL(t);
    }

    /* import a test */
    static importTest(file, formatDkl, csvColumnName, csvColumnType) {
        return new Promise(
            (resolve, reject) => {
                var f = new FileReader();
                f.onload = function(event) {
                    
                    try {
                        var t = formatDkl ? Test.import(JSON.parse(f.result)) : 
                                            Test.importCsv(new CsvContext(file, f.result), csvColumnName, csvColumnType);
                        if (Array.isArray(t)) {
                            for (var i = 0; i < t.length; i++) {
                                DATABASE_MANAGER.addNewTest(t[i]);
                            }
                            resolve();
                        } else if (t) {
                            DATABASE_MANAGER.addNewTest(t);
                            resolve();
                        } else {
                            reject();
                        }
                    } catch (e) {
                        console.warn("Error while importing test", e);
                        reject();
                    }
                    
                }
                f.onerror = () => reject();
                f.readAsText(file);
            }
        );
    }

    /* get the type of file, return true for dkl and false for csv */
    static getTypeFile(file) {
        return new Promise((resolve, reject) => {
            if (file.name.endsWith('.dkl')) {
                resolve(true);
            } else if (file.name.endsWith('.csv')) {
                resolve(false);
            } else {
                var f = new FileReader();
                f.onload = () => {
                    resolve((startsWithIgnoreSpace(f.result, '{') ||
                             startsWithIgnoreSpace(f.result, '[')) &&
                            (endsWithIgnoreSpace(f.result, '}') ||
                             endsWithIgnoreSpace(f.result, ']')));
                }
                f.onerror = reject;
            }
        });
    }

    /* return the blob of the test */
    static getTestBlob(test) {
        return new Blob([test.toString()], {type: 'application/diakoluo'});
    }

    /* return the blob of the test in csv */
    static getTestBlobCsv(test, columnName, columnType) {
        return new Blob([test.getCsv(columnName, columnType)], {type: 'text/csv'});
    }

    /* return the blob of all test in csv */
    static getAllTestBlobCsv(test) {
        return new Promise((resolve, reject) => {
            var data = [];
            DATABASE_MANAGER.forEach((test) => {
                if (test)
                    data.push(test.toString());
                else {
                    if (data) {
                        resolve(new Blob(['[' + data.join(',') + ']'], {type: 'application/diakoluo'}));
                    } else {
                        reject();
                    }
                }
            });
        });
    }

    /* return the cell of the string (escape chars) */
    static toCsvCell(string) {
        var quote = string.indexOf(' ') >= 0 ||
                    string.indexOf(',') >= 0 ||
                    string.indexOf('\n') >= 0 ||
                    string.indexOf('\r') >= 0 ||
                    string.indexOf('\"') >= 0 ||
                    string.indexOf('\'') >= 0 ||
                    string.length <= 0;

        string = string.replaceAll('\\', '\\\\').replaceAll('"', '\\"');
        if (quote) {
            return '"' + string + '"';
        } else {
            return string;
        }
    }

    static readLine(context) {
        var list = [];
        var currentValue = "";

        var c;
        var previousC = ' ';

        var valueStarted = false;
        var quoted = false;
        var hasBeenQuoted = false;


        for (var i = context.i; i < context.content.length; i++) {
            c = context.content[i];
            if (quoted) {
                if (previousC == '"') {
                    if (c == '"') {
                        currentValue += '"';
                        previousC = ' ';
                    } else if (c == FILE_MANAGER.CSV_SEPARATOR) {
                        list.push(currentValue);
                        currentValue = "";
                        valueStarted = false;
                        previousC = ' ';
                        quoted = false;
                    } else if (c == FILE_MANAGER.CSV_LINE_SEPARATOR) {
                        break;
                    } else {
                        // not often because need "test" ,
                        hasBeenQuoted = true;
                        quoted = false;
                        previousC = ' ';
                        currentValue += c;
                    }
                } else if (c == '"') {
                    previousC = c;
                } else {
                    currentValue += c;
                }
            } else {
                if (valueStarted) {
                    if (c == FILE_MANAGER.CSV_SEPARATOR) {
                        if (hasBeenQuoted) {
                            list.push(currentValue);
                            hasBeenQuoted = false;
                        } else {
                            list.push(currentValue.replace(/(^ +)|( +$)/g, ''));
                        }
                        currentValue = "";
                        valueStarted = false;
                    } else if (c == FILE_MANAGER.CSV_LINE_SEPARATOR) {
                        break;
                    } else {
                        currentValue += c;
                    }
                } else {
                    if (c == '"') {
                        quoted = true;
                        valueStarted = true;
                    } else if (c == FILE_MANAGER.CSV_SEPARATOR) {
                        list.push("");
                    } else if (c == FILE_MANAGER.CSV_LINE_SEPARATOR && list.length > 0) {
                        break;
                    } else if (c != ' ' && c != '\t') {
                        valueStarted = true;
                        currentValue += c;
                    }
                }
            }
        }

        if (valueStarted) {
            if (hasBeenQuoted) {
                list.push(currentValue);
            } else {
                list.push(currentValue.replace(/(^ +)|( +$)/g, ''));
            }
        }

        context.i = i + 1; // remove the end line
        if (context.columns >= 0) {
            if (list.length < context.columns && list.length > 0) {
                throw new Error("Not enough columns");
            }
        } else {
            context.columns = list.length;
        }
        return list;
    }
}

class CsvContext {
    constructor(file, content) {
        this.file = file;
        this.content = content;
        this.i = 0;
        this.columns = -1;
    }
}

/* ####################### res/js/diakoluo/sync-manager.js ########################*/

class SyncManager {
    static UPDATE_DELAY = 600_000; // 10 minutes
    static MIN_CACHE = 300_000; // 5 minutes 
    static RELOAD_MAX_TIME = 5_000; // 5 seconds

    static PERMS = ['none', 'view', 'edit', 'share', 'owner'];

    static initialise() {
        var d = this.deserializeData(localStorage.getItem('sync-account'));
        if (d) this.syncManager = new SyncManager(d);
        this.lastUpdate = 0;
        document.addEventListener('visibilitychange', this.onVisibilityChange.bind(this));
        this.onVisibilityChange();
    }

    static setSyncAccount(syncManager) {
        this.syncManager = null;
        this.onVisibilityChange();
        localStorage.setItem('sync-account', JSON.stringify(syncManager));
        this.syncManager = syncManager;
        this.onVisibilityChange();
    }

    static onVisibilityChange() {
        if (document.hidden || !this.syncManager) {
            if (this.updateInterval) clearInterval(this.updateInterval);
            this.updateInterval = 0;
        } else {
            var timeRemaining = this.lastUpdate - Date.now() + this.UPDATE_DELAY
            if (timeRemaining < 0) {
                this.updateInterval = setInterval(this.update.bind(this), this.UPDATE_DELAY);
                this.update();
            } else {
                this.updateInterval = setTimeout(() => {
                    this.updateInterval = setInterval(this.update.bind(this), this.UPDATE_DELAY);
                    this.update();
                }, timeRemaining);
            }
        }
    }

    static update() {
        this.lastUpdate = Date.now();
        this.syncManager?.update().catch(error => {
            console.warn("[SYNC] An error occur while synchronising clients (update)", error);
        });
    }

    static deserializeData(data) {
        data = JSON.parse(data);
        if (data && typeof data.username === "string" && typeof data.password === "string" && data.host) {
            return data;
        } else {
            return null;
        }
    }

    constructor(syncAccount) {
        this.username = syncAccount.username;
        this.password = syncAccount.password;
        this.host = syncAccount.host;
    }

    getPath(root) {
        return this.host + root;
    }

    login() {
        return new Promise((resolve, reject) => {
            fetch(this.getPath('/login'), {
                method: 'POST',
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    username: this.username,
                    password: this.password
                })
            }).then(response => {
                if (response.ok) {
                    resolve({error: false, code: response.status});
                    console.info('[SYNC]', 'Authenticated');
                } else if (response.status === 401) {
                    reject({error: false, code: response.status});
                    console.info('[SYNC]', 'Authentication failed');
                } else {
                    reject({error: true, code: response.status});
                    console.warn('[SYNC]', "Can't authenticate !", response);
                }
            }).catch(error => {
                console.warn('[SYNC]', "Can't authenticate !", error);
                reject({error: true});
            });
        });
    }

    authFetch(path, method='GET', body=null, tryAuth=true) {
        return new Promise((resolve, reject) => {
            fetch(this.getPath(path), {
                method: method,
                credentials: 'include',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: method === 'POST' ? JSON.stringify(body) : null,
            }).then(response => {
                if (response.ok) {
                    resolve(response);
                } else if (response.status === 401) {
                    if (tryAuth) {
                        this.login().then(() => this.authFetch(path, method, body, false).then(resolve).catch(reject))
                                 .catch(() => reject({code: 401}));
                    } else {
                        reject({code: 401});
                    }
                } else {
                    reject({code: response.status});
                }
            }).catch(error => {
                reject({authenticated: false, error: true});
            });
        });
    }

    authFetchJson(path, method='GET', body=null) {
        return new Promise((resolve, reject) => {
            this.authFetch(path, method, body).then(
                response => {
                    response.json()
                    .then(resolve)
                    .catch(() => reject({code: response.code}))
                }
            ).catch(e => reject(e))
        });
    }

    async update() {
        return new Promise(async (resolve, reject) => {
            var testsData = await this.authFetchJson('/test');
            var tests = {};
            var testsKey = [];
            for (let i = 0; i < testsData.you.length; i++) {
                const test = testsData.you[i];
                if (testsKey.indexOf(test.id) < 0) {
                    tests[test.id] = {
                        last_modification: test.last_modification,
                        shareMode: [{type: 'owner'}]
                    };
                    testsKey.push(test.id);
                } else {
                    tests[test.id].shareMode.push({type: 'owner'});
                }
            }
            for (let i = 0; i < testsData.users.length; i++) {
                const test = testsData.users[i];
                if (testsKey.indexOf(test.id) < 0) {
                    tests[test.id] = {
                        last_modification: test.last_modification,
                        shareMode: [{type: 'user', username: test.username, name: test.name}]
                    };
                    testsKey.push(test.id);
                } else {
                    tests[test.id].shareMode.push({type: 'user', username: test.username, name: test.name});
                }
            }
            for (let i = 0; i < testsData.groups.length; i++) {
                const test = testsData.groups[i];
                if (testsKey.indexOf(test.id) < 0) {
                    tests[test.id] = {
                        last_modification: test.last_modification,
                        shareMode: [{type: 'group', name: test.name, long_name: test.long_name}]
                    };
                    testsKey.push(test.id);
                } else {
                    tests[test.id].shareMode.push({type: 'group', name: test.name, long_name: test.long_name});
                }
            }
    
            var updates = [];
    
            var request = DATABASE_MANAGER.forEachSync();
            request.onsuccess = async event => {
                var cursor = event.target.result;
                if (cursor) {
                    const sync = cursor.value;
                    const index = testsKey.indexOf(sync.serverTestId);
                    if (index >= 0) {
                        const testHeader = tests[sync.serverTestId];
                        if (this.isShareModeNotEquals(sync.shareMode, testHeader.shareMode)) {
                            sync.shareMode = testHeader.shareMode;
                            DATABASE_MANAGER.updateSync(sync);
                        }
    
                        if (testHeader.last_modification > sync.lastModification) {
                            updates.push(this.updateTest(sync, testHeader));
                        }
                        testsKey.splice(index, 1);
                    } else {
                        if (sync.lastModification > 0 && sync.shareMode[0].type !== 'link') {
                            cursor.delete();
                            if (sync.testId >= 0) {
                                DATABASE_MANAGER.deleteTest(sync.testId); // TODO
                            }
                        }
                    }
                    cursor.continue();
                } else {
                    for (var index = 0; index < testsKey.length; index++) {
                        const key = testsKey[index];
                        const testHeader = tests[key];
                        let sync = {testId: -1, lastModification: 0, serverTestId: key, shareMode: testHeader.shareMode};
                        DATABASE_MANAGER.addSync(sync).then((event) => {
                            sync.pk = event.target.result;
                            updates.push(this.updateTest(sync, testHeader));
                        });
                    }
    
                    Promise.all(updates).then(resolve);
                }
            }
            request.onerror = reject;
        });
    }

    isShareModeNotEquals(object1, object2) {
        if (object1.length !== object2.length) return true;
        for (var i = 0; i < object1.length; i++) {
            const o1 = object1[i];
            const o2 = object2[i];
            if (o1.type === 'link') {
                if (o2.type !== 'link') return true;
            } else if (o2.type === 'user') {
                if (o2.type !== 'user' || o1.username !== o2.username || o1.name !== o2.name) return true;
            } else if (o2.type === 'group') {
                if (o2.type !== 'group' || o1.name !== o2.name || o1.long_name !== o2.long_name) return true;
            }
        }
        return false
    }

    async updateTest(sync, testHeader) {
        var testData = await this.authFetchJson(`/test/${sync.serverTestId}?last_modification=${sync.lastModification}`);
        var test = Test.import(testData);
        if (test) {
            sync.lastModification = testHeader.last_modification;
            test.sync = sync.pk;
            if (sync.testId > 0) {
                test.id = sync.testId;
                DATABASE_MANAGER.updateTest(test);
                DATABASE_MANAGER.updateSync(sync);
            } else {
                DATABASE_MANAGER.addNewTest(test).onsuccess = event => {
                    sync.testId = event.target.result;
                    DATABASE_MANAGER.updateSync(sync);
                }
            }
        }
    }

    async addTest(test, id, renameFrom) {
        await this.authFetch(`/test/new`, 'POST', {
                "last-modification": 1,
                modified: test.lastModificationDate.getTime(),
                override: true, // TODO
                test: test.getSafeTest(),
                id: id,
                renameFrom: renameFrom
            });
        await this.update();
    }

    async modifyTest(sync, test) {
        await this.authFetch(`/test/${sync.serverTestId}`, 'POST', {
            "last-modification": sync.lastModification,
            modified: test.lastModificationDate.getTime(),
            override: true, // TODO
            test: test.getSafeTest()

        });
        await this.update();
    }

    async deleteTest(test) {
        const event = await DATABASE_MANAGER.getSync(test.sync);
        const sync = event.target.result;
        await this.authFetch(`/test/${sync.serverTestId}`, 'DELETE');
        await this.update();
    }

    async getTestInfo(test) {
        const now = Date.now();
        if (now - test.syncData?.info?.lastRequest < SyncManager.MIN_CACHE && 
            document.timeline.currentTime > SyncManager.RELOAD_MAX_TIME) {
                return test.syncData.info;
        } else {
            const event = await DATABASE_MANAGER.getSync(test.sync);
            const sync = event.target.result;
            try {
                var data = await this.authFetchJson(`/test/${sync.serverTestId}/info`);
            } catch {
                if (test.syncData?.info) {
                    return test.syncData.info;
                } else {
                    throw new Error("Cannot load the informations about the test");
                }
            }
            data.serverTestId = sync.serverTestId;
            data.lastRequest = now;
            if (!test.syncData) test.syncData = {};
            test.syncData.info = data;
            DATABASE_MANAGER.updateTest(test);
            return data;
        }
    }

    async getTestShare(test, forceReload) {
        const now = Date.now();
        if (!forceReload && now - test.syncData?.share?.lastRequest < SyncManager.MIN_CACHE && 
            document.timeline.currentTime > SyncManager.RELOAD_MAX_TIME) {
                return test.syncData.share;
        } else {
            const event = await DATABASE_MANAGER.getSync(test.sync);
            const sync = event.target.result;
            try {
                var data = await this.authFetchJson(`/test/${sync.serverTestId}/share`);
            } catch (e) {
                if (test.syncData?.share) {
                    return test.syncData.share;
                } else {
                    throw new Error("Cannot load the shares about the test");
                }
            }
            data.lastRequest = now;
            if (!test.syncData) test.syncData = {};
            test.syncData.share = data;
            DATABASE_MANAGER.updateTest(test);
            return data;
        }
    }

    async setTestShare(test, type, perms, name, action) {
        const event = await DATABASE_MANAGER.getSync(test.sync);
        const sync = event.target.result;
        return this.authFetch(`/test/${sync.serverTestId}/share`, 'POST', {
            action: action,
            name: name,
            perms: perms,
            type: type
        });
    }
}
DATABASE_MANAGER.initAsyncFunc.then(SyncManager.initialise.bind(SyncManager));


/* ######################### res/js/diakoluo/test/test.js #########################*/

class Test {
    /* cast an object to Test. / Add functions to the object*/
    static cast(test) {
        var nb_c = test.columns.length;
        for (var i = 0; i < test.data.length; i++) {
            if (test.data[i].length != nb_c) {
                throw new Error("Data length isn't the same as columns");
            }
        }

        var c = [];
        for (var i = 0; i < test.columns.length; i++) {
            c.push(Column.cast(test.columns[i]));
        }
        test.columns = c;

        return Object.assign(new Test(), test);
    }

    static import(test) {
        if (Array.isArray(test)) {
            var tests = [];
            for (var i = 0; i < test.length; i++) {
                tests.push(Test.import(test[i]));
            }
            return tests;
        }
        if (typeof test?.title !== "string" || 
            typeof test.description !== "string" ||
            !Array.isArray(test.columns) ||
            !Array.isArray(test.data)||
            typeof test.createDate !== "string" ||
            typeof test.lastModificationDate !== "string") {            
            
            return null;
        }

        test.createDate = new Date(test.createDate);
        test.lastModificationDate = new Date(test.lastModificationDate);
        if (test.sync) delete test.sync;

        var nb_c = test.columns.length;
        for (var i = 0; i < test.data.length; i++) {
            if (test.data[i].length != nb_c) {
                throw new Error("Data length isn't the same as columns");
            }
        }

        var columns = [];
        var c;
        for (var i = 0; i < test.columns.length; i++) {
            c = Column.import(test.columns[i]);
            if (c)
                columns.push(c);
            else return null;
        }
        test.columns = columns;

        for (var i = 0; i < test.data.length; i++) {
            for (var j = 0; j < test.columns.length; j++) {
                if (!test.columns[j].verifyData(test.data[i][j]))
                    return null;
            } 
        }
        return Object.assign(new Test(), test);   
    }

    /* import from a csv file */
    static importCsv(csv, columnName, columnType) {
        var columns = [];
        var data = [];
        if (columnName) {
            var columnsName = FILE_MANAGER.readLine(csv);
        }

        if (columnType) {
            var columnType = FILE_MANAGER.readLine(csv);
        }

        var line = FILE_MANAGER.readLine(csv);
        for (var i = 0; i < line.length; i++) {
            columns.push(new (Column.getColumnClassCsv(columnType?.[i]))
                (columnName ? columnsName[i] : (I18N.getTranslation('default-column-title') + ' ' + (i + 1))))
        }

        var row;
        do {
            row = [];
            for (var i = 0; i < columns.length; i++) {
                row.push(columns[i].getDataFromCsv(line[i]));
            }
            data.push(row);
        } while ((line = FILE_MANAGER.readLine(csv)).length > 0);

        if (columns.length > 0) {
            var t = new Test(csv.file.name.replace(/\.[^/.]*$/, ''));
            if (csv.file.lastModified) t.createDate = t.lastModificationDate = new Date(csv.file.lastModified);
            t.columns = columns;
            t.data = data;
            return t;
        } else {
            return null;
        }
    }

    /* construct an object, if first param is null, don't create any fields */
    constructor(title, description = "") {
        if (title != null) {
            this.title = title;
            this.description = description;
            this.createDate = new Date();
            this.lastModificationDate = new Date();
            this.columns = [];
            this.data = [];
        }
    }

    /* get the header of the test*/
    getHeader() {
        return {title: this.title, description: this.description, playable: this.isPlayable(), id: this.id, sync: this.sync};
    }

    /* get if the test is playable */
    isPlayable() {
        return this.data.length > 1 && this.isPlayableColumns();
    }

    isPlayableColumns() {
        if (this.columns.length > 1) {
            var set_ask = false;
            var set_show = false;
            var c;
            for (var i = 0; i < this.columns.length; i++) {
                c = this.columns[i];
                if (c.getSettings(Column.SET_CAN_BE_SHOW)) set_show = true;
                if (c.getSettings(Column.SET_CAN_BE_ASK)) set_ask = true;
                if (set_ask && set_show) return true;
            }
        }
        return false;
    }

    /* set the last modification date to now */
    registerModificationDate() {
        this.lastModificationDate = new Date();
    }

    /* add a column return the index of the column added*/
    addColumn(column) {
        for (var i = 0; i < this.data.length; i++) {
            this.data[i].push(column.getDefaultValue());
        }
        return this.columns.push(column) - 1;
    }

    /* remove a column */
    removeColumn(index) {
        for (var i = 0; i < this.data.length; i++) {
            this.data[i].splice(index, 1);
        }

        this.columns.splice(index, 1);
    }

    /* Add a data and return the index of the item added */
    addData() {
        var d = [];
        for (var i = 0; i < this.columns.length; i++) {
            d.push(this.columns[i].getDefaultValue());
        }
        return this.data.push(d) - 1;
    }

    /* remove a test */
    removeData(index) {
        this.data.splice(index, 1);
    }

    /* get string */
    toString() {
        var id = this.id;
        var sync = this.sync;
        var syncData = this.syncData;
        delete this.id;
        delete this.sync;
        delete this.syncData;
        var str = JSON.stringify(this);
        this.id = id;
        this.sync = sync;
        this.syncData = syncData;
        return str;
    }

    /**
     * Get a test safe to transfer (without id and sync)
     */
    getSafeTest() {
        var t = Object.assign({}, this);
        delete t.id;
        delete t.sync;
        delete t.syncData;
        return t;
    }

    /* get the test as csv file */
    getCsv(columnName, columnType) {
        var csv = "";
        if (columnName) {
            for (var i = 0; i < this.columns.length; i++) {
                if (i > 0) csv += FILE_MANAGER.CSV_SEPARATOR;
                csv += FILE_MANAGER.toCsvCell(this.columns[i].name);
            }
            csv += FILE_MANAGER.CSV_LINE_SEPARATOR;
        }

        if (columnType) {
            for (var i = 0; i < this.columns.length; i++) {
                if (i > 0) csv += FILE_MANAGER.CSV_SEPARATOR;
                csv += FILE_MANAGER.toCsvCell(this.columns[i].constructor.TYPE);
            }
            csv += FILE_MANAGER.CSV_LINE_SEPARATOR;
        }

        for (var i = 0; i < this.data.length; i++) {
            for (var j = 0; j < this.columns.length; j++) {
                if (j > 0) csv += FILE_MANAGER.CSV_SEPARATOR;
                csv += FILE_MANAGER.toCsvCell(this.columns[j].getCsvValue(this.data[i][j]));
            }
            csv += FILE_MANAGER.CSV_LINE_SEPARATOR;
        }
        return csv;
    }

    getFilename() {
        return this.title
            .replaceAll(' ', '_')
            .replaceAll('.', '_')
            .replaceAll('/', '_')
            .replaceAll('\\', '_') + '.dkl';
    }
}

/* #################### res/js/diakoluo/test/columns/column.js ####################*/

var columnsClass = [];

class Column {
    // first 1 byte is reserved
    static SET_CAN_BE_SHOW = 1; // 1 << 0
    static SET_CAN_BE_ASK = 2; // 1 << 1
    static DEFAULT_SETTINGS = Column.SET_CAN_BE_SHOW | Column.SET_CAN_BE_ASK;

    /* cast a column */
    static cast(column) {
        var columnClass;
        for (var i = 0; i < columnsClass.length; i++) {
            if (column.type == columnsClass[i].TYPE || columnsClass[i].name) { // backward compatibilty
                columnClass = columnsClass[i];
                break;
            }
        }
        if (columnClass) {
            return Object.assign(new columnClass(), column);
        } else {
            throw new Error("Unknown type of column !");
        }
    }

    /* import a column */
    static import(column) {
        if (typeof column.type !== "string") {
            return null;
        }
        return Column.cast(column);
    }

    /* get the skipped view */
    static getSkippedView() {
        var e = document.createElement('div');
        e.textContent = I18N.getTranslation('skipped');
        e.classList = 'skipped-answer text';
        return e;
    }

    /* get the class constructor from the type */
    static getColumnClassCsv(type) {
        var columnClass;
        if (type) type = type.toLowerCase();
        else return ColumnString;
        for (var i = 0; i < columnsClass.length; i++) {
            if (type == columnsClass[i].TYPE.toLowerCase()) {
                return columnsClass[i];
            }
        }

        return ColumnString;
    }

    /* create a column if second field is null, 0 fieds will be instentiate. Type represent the class name id */
    constructor(type, name, description = "") {
        this.type = type;
        if (name != null) {
            this.name = name;
            this.description = description;
            this.settings = Column.DEFAULT_SETTINGS;
        }
    }

    /* Get a string that represent the data */
    getDataValueString(data) {
        return data.value;
    }

    /* Get the csv value (not escaped) */
    getCsvValue(data) {
        return data.value;
    }

    /* get a dom element that show the data */
    getViewView(data) {
        var e = document.createElement('div');
        e.classList.add('text');
        if (data.value)
            e.textContent = data.value;
        else {
            e.textContent = I18N.getTranslation('empty-string');
            e.style.fontStyle = "italic";
        }
        return e;
    }

    /* get the view that can edit the data */
    getEditView(data) {
        var i = this.getTestView(data);
        i.value = data.value;
        return i;
    }

    /* get the view to prompt when tested, like edit but without the data */
    getTestView(data) {
        var i = document.createElement('input');
        i.type = 'text';
        i.placeholder = this.name;
        return i;
    }

    /* get the view for the play card page (it's view view but bigger) */
    getCardView(data) {
        return this.getViewView(data);
    }

    /* set the score and show the answer of the view and apply score */
    updateAnswerTestView(data, view, score) {
        var value = this.getValueFromView(view);
        if (this.isRight(data, value)) {
            score?.pushScore(1, 1);

            var e = this.getViewView(value);
            e.classList.add('right-answer');
            return e;
        } else if (this.isSkipped(data, value)) {
            score?.pushScore(0, 1);

            var div = document.createElement('div');
            div.appendChild(Column.getSkippedView());
            var e = this.getViewView(data);
            e.classList.add('answer-answer');
            div.appendChild(e);

            return div;
        }  else {
            score?.pushScore(0, 1);

            var div = document.createElement('div');
            var e = this.getViewView(value);
            e.classList.add('wrong-answer');
            div.appendChild(e);

            e = this.getViewView(data);
            e.classList.add('answer-answer');
            div.appendChild(e);
            return div;
        }
    }

    /* get the value stored in the view */
    getValueFromView(view) {
        return {value: view.value};
    }

    /* set the value from the value stored in the view */
    setValueFromView(data, view) {
        data.value = view.value;
    }

    /* get if a value is right */
    isRight(data, value) {
        return data.value === value.value;
    }

    /* get if a value is skipped */
    isSkipped(data, value) {
        return value.value === "";
    }

    /* get the default value of data for the column */
    getDefaultValue() {
        throw new Error("Not overrided");
    }

    /* get the settings view of the column */
    getViewColumnSettings() {
        var div = document.createElement('div');
        div.classList = ['unique-column'];
        
        div.appendChild(
            VIEW_UTILS.booleanView(
                this.getSettings(Column.SET_CAN_BE_SHOW), 
                I18N.getTranslation('column-can-show')
            )
        );
        div.appendChild(
            VIEW_UTILS.booleanView(
                this.getSettings(Column.SET_CAN_BE_ASK), 
                I18N.getTranslation('column-can-ask')
            )
        );
        return div;
    }

    /* get the settings view of the column */
    getEditColumnSettings() {
        var div = document.createElement('div');
        div.classList = ['unique-column'];
        
        div.appendChild(VIEW_UTILS.booleanEdit(
            this.getSettings(Column.SET_CAN_BE_SHOW), 
            I18N.getTranslation('column-can-show'),
            'column-show'
        ));

        div.appendChild(VIEW_UTILS.booleanEdit(
            this.getSettings(Column.SET_CAN_BE_ASK), 
            I18N.getTranslation('column-can-ask'),
            'column-ask'
        ));
        return div;
    }

    /* set the settings from the view */
    setEditColumnSettings(view) {
        this.setSettings(Column.SET_CAN_BE_SHOW, view.querySelector('#column-show').checked);
        this.setSettings(Column.SET_CAN_BE_ASK, view.querySelector('#column-ask').checked);
    }

    /* get some parameters in settings */
    getSettings(params) {
        return (this.settings & params) === params;
    }

    /* set some parameters in settings */
    setSettings(params, value) {
        this.settings = value ? this.settings | params : this.settings & ~params;
    }

    /* when importing, verify that a data is valid */
    verifyData(data) {
        return typeof data.value === "string";
    }

    /* cast a data from a csv cell */
    getDataFromCsv(cell) {
        return {value: cell};
    }
}   

/* ################ res/js/diakoluo/test/columns/column-string.js #################*/

class ColumnString extends Column {

    static SET_CASE_SENSITIVE = 256; // 1 << 8
    static SET_TRIM_SPACES = 512; // 1 << 9
    static SET_LONG = 1024; // 1 << 10

    static TYPE = "String";

    constructor(name, description="") {
        super(ColumnString.TYPE, name, description);
        if (name) {
            this.settings |= ColumnString.SET_TRIM_SPACES;
        }
    }

    /* get a dom element that show the data */
    getViewView(data) {
        var e = super.getViewView(data);
        if (this.getSettings(ColumnString.SET_LONG)) {
            e.classList.add('column-string-long');
        }
        return e;
    }

    /* get card view */
    getCardView(data) {
        if (this.getSettings(ColumnString.SET_LONG)) {
            var e = super.getCardView(data);
            e.classList.add('column-string-long');
            return e;
        } else {
            var e = document.createElement('h1');
            e.classList.add('big');
            if (data.value)
                e.textContent = data.value;
            else {
                e.textContent = I18N.getTranslation('empty-string');
                e.style.fontStyle = "italic";
            }
            return e;
        }
    }

    /* get the default value of data for the column */
    getDefaultValue() {
        return {value: ""};
    }

    /* get the view to prompt when tested, like edit but without the data */
    getTestView(data) {
        if (this.getSettings(ColumnString.SET_LONG)) {
            var i = document.createElement('textarea');
            i.onkeydown = event => {
                if (event.keyCode === 13)
                    event.stopPropagation(); // don't submit on enter
            }
            i.classList.add('column-string-long');
        } else {
            var i = document.createElement('input');
            i.type = 'text';
            i.placeholder = this.name;
        }
        return i;
    }

    /* get if a value is right */
    isRight(data, value) {
        if (this.getSettings(ColumnString.SET_TRIM_SPACES)) {
            var dv = data.value.trim(); 
            var v = value.value.trim(); 
        } else {
            var dv = data.value; 
            var v = value.value;
        }
        
        if (this.getSettings(ColumnString.SET_CASE_SENSITIVE)) {
            return dv === v;
        } else {
            return dv.toLowerCase() === v.toLowerCase();
        }
    }

    /* get the settings view of the column */
    getViewColumnSettings() {
        var div = super.getViewColumnSettings();
        div.appendChild(document.createElement('hr'));

        div.appendChild(
            VIEW_UTILS.booleanView(
                this.getSettings(ColumnString.SET_CASE_SENSITIVE), 
                I18N.getTranslation('column-string-case-sensitive')
            )
        );
        div.appendChild(
            VIEW_UTILS.booleanView(
                this.getSettings(ColumnString.SET_TRIM_SPACES), 
                I18N.getTranslation('column-string-trim-spaces')
            )
        );
        div.appendChild(
            VIEW_UTILS.booleanView(
                this.getSettings(ColumnString.SET_LONG), 
                I18N.getTranslation('column-string-long')
            )
        );

        return div;
    }

    /* get the settings view of the column */
    getEditColumnSettings() {
        var div = super.getEditColumnSettings();
        div.appendChild(document.createElement('hr'));

        div.appendChild(VIEW_UTILS.booleanEdit(
            this.getSettings(ColumnString.SET_CASE_SENSITIVE), 
            I18N.getTranslation('column-string-case-sensitive'),
            'column-case-sensitive'
        ));

        div.appendChild(VIEW_UTILS.booleanEdit(
            this.getSettings(ColumnString.SET_TRIM_SPACES), 
            I18N.getTranslation('column-string-trim-spaces'),
            'column-trim-spaces'
        ));

        div.appendChild(VIEW_UTILS.booleanEdit(
            this.getSettings(ColumnString.SET_LONG), 
            I18N.getTranslation('column-string-long'),
            'column-long'
        ));
        return div;
    }

    /* set the settings from the view */
    setEditColumnSettings(view) {
        super.setEditColumnSettings(view);
        this.setSettings(ColumnString.SET_CASE_SENSITIVE, view.querySelector('#column-case-sensitive').checked);
        this.setSettings(ColumnString.SET_TRIM_SPACES, view.querySelector('#column-trim-spaces').checked);
        this.setSettings(ColumnString.SET_LONG, view.querySelector('#column-long').checked);
    }
}
columnsClass.push(ColumnString);